Библиотека проекта Timelon состоит из нескольких классов в двух пространствах имен:
- TimelonCl
- TimelonCl.Data

TimelonCl

Роль основного класса играет Manager (Менеджер), который отвечает за сохранение и загрузку данных,
а также хранение объектов, полученных из этих данных. Стоит отметить, что Менеджер реализует
шаблон проектирования Singleton (Класс-одиночка), который не позволит создать больше одного
экземпляра этого класса. Это необходимо для корректной работы с файлами данных. Также эта
реализация не позволит разработчикам других решений допустить неприятную ошибку при работе
с классом Менеджер, случайно или же специально создав второй экземпляр класса со всеми
загруженными в него данными, которые могут отличаться.

Следует иметь ввиду, что при использовании Менеджера в своих решениях, желательно
инициализировать экземпляр класса как можно раньше, если он не был инициализирован до этого.

Менеджер содержит в себе сортированный список всех объектов CardList (Список Карт, подробнее
о нем изложено ниже) и базовые методы работы с ним, такие как:
- GetList (Получение списка)
- SetList (Вставка Списка)
- RemoveList (Удаление Списка)
- ContainsList (Проверка на существование Списка)
- SearchByContent (Поиск по контенту во всех Списках)

Также Менеджер имеет метод InjectEssentials (Внедрить закрепленные Списки), который каждый раз
при загрузке или сохранении данных проверяет наличие в сортированном списке закрепленных
Списков Карт. Закрепленные Списки - это Списки по-умолчанию, которые присутствуют в Менеджере
не зависимо от действий пользователя. Они нужны для быстрого доступа к функционалу Списков Карт
без необходимости тратить время на создание нового. Они имеют закрепленные идентификаторы,
которые не позволят затеряться в возможном множестве созданных Списков Карт.

За работу с данными отвечают всего 2 метода: Sync (Сохранить данные в файл) и Load (Загрузить
данные из файла). Файл по-умолчанию находится в директории "Мои документы" в папке Timelon.
Оба этих метода работают со встроенным функционалом сериализации объектов в XML. Подробнее об
этом изложено в TimelonCl.Data.

Класс Util в пространстве имен TimelonCl отвечает за реализацию самых разнообразных
потребностей, которые возникают при активной разработке программного обеспечения. На текущей
стадии он хранит в себе только лишь работу с генератором псевдо-случайных чисел. А конкретно:
- Статический доступ к глобальному генератору псевдо-случайных чисел (Random)
- Функция NextBool (Получение следующего случайного булевого значения)
- Функция NextString (Получение следующей случайной строки заданной длины)
- Функция NextCollectionIndex (Получение следующего случайного индекса заданной коллекции)
- Функции NextDateTime (Получение следующих даты и времени (DateTime))

TimelonCl.Data

Самое интересное происходит именно в пространстве имен TimelonCl.Data, хранящем в себе основные
классы, экземпляры которых участвующит в обороте данных между постоянной и оперативной памятью.
А именно:
- Абстрактный класс Unique (Уникальный Класс)
- Абстрактный класс DataContainer (Контейнер Данных)
- Класс DateTimeContainerData (Данные Контейнера Дат)
- Класс CardData (Данные Карты)
- Класс CardListData (Данные Списка Карт)
- Класс DateTimeContainer (Контейнер Дат)
- Класс Card (Карта)
- Класс CardList (Список Карт)

Уникальный Класс отвечает в первую очередь за автоматическую генерацию уникальных
идентификаторов в текущей сессии. Также он хранит в себе поля и доступ к ним для идентификаторов
и названий объектов, наследующих эту абстракцию. Генерация происходит при помощи статического
поля инкрементора, который хранит в себе текущее значение идентификатора для наследуемого типа.
Функция Register (Регистрация идентификатора) регистрирует указанный идентификатор в текущей
сессии для предотвращения дублирования при, например, загрузке объекта из файла. Функция
UniqueId (Получение следующего идентификатора) служит для генерирования идентификатора для
новых объектов-наследников. Разработчики других решений ограничены в доступе к этим функциям
во избежание создания ошибок. Уникальный Класс всю работу берет на себя, достаточно только
унаследовать его.

Контейнер Данных служит только для того, чтобы наследники могли быть беспрепятственно
сериализованы в XML формат. Он имеет атрибут Serializable (Сериализируемый) и хранит в себе
пустой конструктор и метод ToXmlString (Сериализация в XML).

Классы Данные Контейнера Дат, Данные Карты и Данные Списка Карт наследуют абстракцию
Контейнер Данных. Они существуют обособленно от связанных с ними объектов и хранят в себе
пустые публичные поля с полным доступом для хранения данных основных объектов и их сериализации
стандартными методами. Таким образом, они позволяют сохранить в основных объектах необходимую
инкапсуляцию.

Контейнер Дат, Карта и Список Карт содержат в себе функции FromData и методы ToData для
безопасной конвертации из соответствующих контейнеров данных в экземпляр класса и обратно. Таким
образом, контейнеры данных участвуют в качестве посредников при сериализации и десериализации
в Менеджере в методах Sync и Load.

Контейнер Дат служит для хранения в себе нескольких экземпляров класса DateTime:
- Created (дата создания)
- Updated (дата обновления или null)
- Planned (запланированная дата или null)
Все эти даты относятся к определенному экземпляру класса Карта. Присутствует возможность
получения и изменения дат, а также проверка на статус обновленности и запланирования. Стоит
обратить внимание на то, что дата обновления и запланированная дата напрямую зависят от даты
создания - они не могут превышать ее. Соответственно, при изменении даты создания зависимые от
нее даты будут перепроверены автоматически.

Карта наследует Уникальный Класс и представляет собой карточку дела. По большей части этот класс
содержит в себе основные поля, характерные для карточки.

Список Карт, также как и Карта, наследует Уникальный Класс и представляет собой список карточек
дел. В качестве способа хранения экземпляров Карт в классе используется Dictionary (Библиотека)
из-за отличной скорости поиска и возможности использования идентификаторов в качестве ключа.
Присутствуют как базовые методы, такие как Get (Получить Карту), Set (Сохранить Карту),
Remove (Удалить Карту), Contains (Проверить наличие Карты), так и методы отвечающие за сортировку
и поиск. Так как Библиотека позволяет мгновенно получить Карту через ее идентификатор вне
зависимости от количества хранимых Карт, достаточно произвести сортировку один раз и занести
идентификаторы в отдельный список для быстрого доступа. Таких списков в классе три:
- idListDefault (идентификаторы по дате обновления)
- idListImportant (идентификаторы по статусу важности)
- idListCompleted (идентификаторы по статусу выполнения)
Этим спискам соответствуют методы:
- GetListDefault (Получение Карт, отсортированных по дате обновления)
- GetListImportant (Получение Карт, отсортированных по статусу важности)
- GetListCompleted (Получение Карт, отсортированных по статусу выполнения)
Однако, при обновлении Библиотеки (например, сохранении новой Карты), сортировку необходимо
произвести заново. Для управления статусом сортировки применяется перечисление SortOrder
(Направление Сортировки):
- Initial (Карты необходимо отсортировать (используется только внутри класса))
- Unsorted (В произвольном порядке)
- Ascending (По возрастанию)
- Descending (По убыванию)
Соответственно, с помощью этого перечисления при использовании методов получения отсортированных
Карт существует возможность указать необходимый порядок.